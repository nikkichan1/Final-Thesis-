---
title: "Flood Extreme Estimates using non-stationary and outlier-removal approaches"
output: html_notebook
Author: Nicole
Description: This is a original copy of exmple.Rmd to illustrate the main code of the thesis. Detailed processing codes are available in R scripts.
editor_options: 
  markdown: 
    wrap: 72
---

<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img src="https://i.creativecommons.org/l/by/4.0/88x31.png" alt="Creative Commons License" style="border-width:0"/></a><br />This
work is licensed under a
<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative
Commons Attribution 4.0 International License</a>.

-   **load the packages and data **
```{r}
# Load the package
rm(list=ls())
library(dplyr) 
library(extRemes)
library(readr)
library(reshape2)
library(GenSA)
library(gamlss) 
library(evd) 
library(lubridate)
library(nsRFA)
library(Rlof)
library(Lmoments)
library(ggplot2)
library(strucchange)
library(cowplot)
library(gridExtra)            
library(hydroGOF)
```

-   **GAMLSS fitting approaches: Stationary and Non-Stationary**
Input: dataTemp (a dataframe containing two columns: maxVal and year)
this function using the LOGNO, GU, GA, WEI to fit the data, 4
conditions, 1 constant, 2 changing mu, 3 changing sigma,4 changing both,
return the dataTemp with some adding columns (mu sigma aic sbc under all
conditions)
```{r}
fitted_infor_4models_4conditions <- function(dataTemp) {
  #############
  ###four distibutions with two-parameters
  # LOGNO GU (identity, log); GA WEI (log, log)

  Q <- dataTemp$maxVal
  qcov <- dataTemp$year

  # LOGNO,  constant u sigma
  estGAM<-gamlss(Q~1,sigma.formula = ~1,family = LOGNO());summary(estGAM) 
  
  dataTemp$mu_1_LOGNO <- estGAM[["mu.coefficients"]][1]; dataTemp$sigma_1_LOGNO <- exp(estGAM[["sigma.coefficients"]][1])
  dataTemp$AIC_1_LOGNO <- estGAM$aic; dataTemp$SBC_1_LOGNO <-  estGAM$sbc

  
  # LOGNO,  time-varying u  constant sigma
  estGAM<-gamlss(Q~qcov,sigma.formula = ~1,family = LOGNO());summary(estGAM) 
  
  dataTemp$mu_2_LOGNO <- estGAM[["mu.coefficients"]][1] + estGAM[["mu.coefficients"]][2]*qcov; 
  dataTemp$sigma_2_LOGNO <- exp(estGAM[["sigma.coefficients"]][1])
  dataTemp$AIC_2_LOGNO <- estGAM$aic; dataTemp$SBC_2_LOGNO <-  estGAM$sbc

  
  # LOGNO,   constant u  time-varying sigma
  estGAM<-gamlss(Q~1,sigma.formula = ~qcov,family = LOGNO());summary(estGAM)
  
  dataTemp$mu_3_LOGNO <- estGAM[["mu.coefficients"]][1]
  dataTemp$sigma_3_LOGNO <- exp(estGAM[["sigma.coefficients"]][1] + estGAM[["sigma.coefficients"]][2]*qcov)
  dataTemp$AIC_3_LOGNO <- estGAM$aic; dataTemp$SBC_3_LOGNO <-  estGAM$sbc

  # LOGNO,   time-varying  u   sigma
  estGAM<-gamlss(Q~qcov,sigma.formula = ~qcov,family = LOGNO());summary(estGAM)
  
  dataTemp$mu_4_LOGNO <-  estGAM[["mu.coefficients"]][1]+ estGAM[["mu.coefficients"]][2]*qcov; 
  dataTemp$sigma_4_LOGNO <- exp(estGAM[["sigma.coefficients"]][1] + estGAM[["sigma.coefficients"]][2]*qcov)
  dataTemp$AIC_4_LOGNO <- estGAM$aic; dataTemp$SBC_4_LOGNO <-  estGAM$sbc

  
  
  # GU,  constant u sigma
  estGAM<-gamlss(Q~1,sigma.formula = ~1,family = GU());summary(estGAM) 
  
  dataTemp$mu_1_GU <- estGAM[["mu.coefficients"]][1]; dataTemp$sigma_1_GU <- exp(estGAM[["sigma.coefficients"]][1])
  dataTemp$AIC_1_GU <- estGAM$aic; dataTemp$SBC_1_GU <-  estGAM$sbc

  
  # GU,  time-varying u  constant sigma
  estGAM<-gamlss(Q~qcov,sigma.formula = ~1,family = GU());summary(estGAM) 
  
  dataTemp$mu_2_GU <- estGAM[["mu.coefficients"]][1] + estGAM[["mu.coefficients"]][2]*qcov; 
  dataTemp$sigma_2_GU <- exp(estGAM[["sigma.coefficients"]][1])
  dataTemp$AIC_2_GU <- estGAM$aic; dataTemp$SBC_2_GU <-  estGAM$sbc

  
  # GU,   constant u  time-varying sigma
  estGAM<-gamlss(Q~1,sigma.formula = ~qcov,family = GU());summary(estGAM)
  
  dataTemp$mu_3_GU <- estGAM[["mu.coefficients"]][1]
  dataTemp$sigma_3_GU <- exp(estGAM[["sigma.coefficients"]][1] + estGAM[["sigma.coefficients"]][2]*qcov)
  dataTemp$AIC_3_GU <- estGAM$aic; dataTemp$SBC_3_GU <-  estGAM$sbc

  # GU,   time-varying  u   sigma
  estGAM<-gamlss(Q~qcov,sigma.formula = ~qcov,family = GU());summary(estGAM)
  
  dataTemp$mu_4_GU <-  estGAM[["mu.coefficients"]][1]+ estGAM[["mu.coefficients"]][2]*qcov; 
  dataTemp$sigma_4_GU <- exp(estGAM[["sigma.coefficients"]][1] + estGAM[["sigma.coefficients"]][2]*qcov)
  dataTemp$AIC_4_GU <- estGAM$aic; dataTemp$SBC_4_GU <-  estGAM$sbc

  # GA,  constant u sigma
  estGAM<-gamlss(Q~1,sigma.formula = ~1,family = GA());summary(estGAM) 
  
  dataTemp$mu_1_GA <- exp(estGAM[["mu.coefficients"]][1]); dataTemp$sigma_1_GA <- exp(estGAM[["sigma.coefficients"]][1])
  dataTemp$AIC_1_GA <- estGAM$aic; dataTemp$SBC_1_GA <-  estGAM$sbc

  # GA,  time-varying u  constant sigma
  estGAM<-gamlss(Q~qcov,sigma.formula = ~1,family = GA());summary(estGAM) 
  
  dataTemp$mu_2_GA <- exp(estGAM[["mu.coefficients"]][1]+ estGAM[["mu.coefficients"]][2]*qcov); 
  dataTemp$sigma_2_GA <- exp(estGAM[["sigma.coefficients"]][1])
  dataTemp$AIC_2_GA <- estGAM$aic; dataTemp$SBC_2_GA <-  estGAM$sbc
  
  # GA,   constant u  time-varying sigma
  estGAM<-gamlss(Q~1,sigma.formula = ~qcov,family = GA());summary(estGAM)
  
  dataTemp$mu_3_GA <- exp(estGAM[["mu.coefficients"]][1])
  dataTemp$sigma_3_GA <- exp(estGAM[["sigma.coefficients"]][1] + estGAM[["sigma.coefficients"]][2]*qcov)
  dataTemp$AIC_3_GA <- estGAM$aic; dataTemp$SBC_3_GA <-  estGAM$sbc

  # GA,   time-varying  u   sigma
  estGAM<-gamlss(Q~qcov,sigma.formula = ~qcov,family = GA());summary(estGAM)
  
  dataTemp$mu_4_GA <-  exp(estGAM[["mu.coefficients"]][1]+ estGAM[["mu.coefficients"]][2]*qcov); 
  dataTemp$sigma_4_GA <- exp(estGAM[["sigma.coefficients"]][1] + estGAM[["sigma.coefficients"]][2]*qcov)
  dataTemp$AIC_4_GA <- estGAM$aic; dataTemp$SBC_4_GA <-  estGAM$sbc

  
  # WEI,  constant u sigma
  estGAM<-gamlss(Q~1,sigma.formula = ~1,family = WEI());summary(estGAM) 
  
  dataTemp$mu_1_WEI <- exp(estGAM[["mu.coefficients"]][1]); dataTemp$sigma_1_WEI <- exp(estGAM[["sigma.coefficients"]][1])
  dataTemp$AIC_1_WEI <- estGAM$aic; dataTemp$SBC_1_WEI <-  estGAM$sbc

  
  # WEI,  time-varying u  constant sigma
  estGAM<-gamlss(Q~qcov,sigma.formula = ~1,family = WEI());summary(estGAM) 
  
  dataTemp$mu_2_WEI <- exp(estGAM[["mu.coefficients"]][1]+ estGAM[["mu.coefficients"]][2]*qcov); 
  dataTemp$sigma_2_WEI <- exp(estGAM[["sigma.coefficients"]][1])
  dataTemp$AIC_2_WEI <- estGAM$aic; dataTemp$SBC_2_WEI <-  estGAM$sbc

  
  # WEI,   constant u  time-varying sigma
  estGAM<-gamlss(Q~1,sigma.formula = ~qcov,family = WEI());summary(estGAM)
  
  dataTemp$mu_3_WEI <- exp(estGAM[["mu.coefficients"]][1])
  dataTemp$sigma_3_WEI <- exp(estGAM[["sigma.coefficients"]][1] + estGAM[["sigma.coefficients"]][2]*qcov)
  dataTemp$AIC_3_WEI <- estGAM$aic; dataTemp$SBC_3_WEI <-  estGAM$sbc

  # WEI,   time-varying  u   sigma
  estGAM<-gamlss(Q~qcov,sigma.formula = ~qcov,family = WEI());summary(estGAM)
  
  dataTemp$mu_4_WEI <-  exp(estGAM[["mu.coefficients"]][1]+ estGAM[["mu.coefficients"]][2]*qcov); 
  dataTemp$sigma_4_WEI <- exp(estGAM[["sigma.coefficients"]][1] + estGAM[["sigma.coefficients"]][2]*qcov)
  dataTemp$AIC_4_WEI <- estGAM$aic
  dataTemp$SBC_4_WEI <-  estGAM$sbc
  
  return(dataTemp) 
}
```

-   **Outlier removal approaches**
1)  [Reject_outliers_method1]{.underline}(dataTemp,threshold_returnPeriod,chunk)
Input: dataTemp,threshold_returnPeriod,chunk
Output: dataTemp (updated by replacing outliers with NA in each window,
that outlier is larger than returnlevel of data within this moving
window)
2)  [Reject_outliers_method2]{.underline}(dataTemp,window_size,threshold_times)
Input: dataTemp,window_size,threshold_times=(2 or 3)
Output: dataTemp (updated by replacing outliers with NA, we also
return the times)
```{r}
##############
###reject_outliers_method1, dataTemp  -> chunk_size (e.g., 30) as one group, then determine the discharge at the given threshold_returnPeriod at each group. and set the records > discharge as NA at each group, then combine them and return the dataframe results

Reject_outliers_method1 <- function(dataTemp,threshold_returnPeriod,chunk) {
  if(ceiling(nrow(dataTemp)/chunk)==1){
    dataTemp$r <- 1
  }else{
    dataTemp$r <- cut(seq_along(dataTemp$maxVal), 
                    breaks = ceiling(nrow(dataTemp)/chunk), labels = FALSE)
  }
  
  
  d <- split(dataTemp, dataTemp$r)
  
  # Calculate return levels for each sample
  return_levels <- lapply(d, function(sample) {
    fit_gev <- fevd(sample$maxVal)
    return.level(fit_gev, return.period = threshold_returnPeriod)})
  # Extract upper outliers
  b <- as.numeric(unlist(return_levels))
  
  tempData <- bind_rows(lapply(seq_along(d), function(i) {
    d_chunk <- d[[i]]
    b_chunk <- b[i]
    subset <- d_chunk[d_chunk$maxVal > b_chunk,]
    if(nrow(subset) > 0) {subset} else {NULL}}))
  

  results<-dataTemp
  results[dataTemp$maxVal %in% tempData$maxVal,]<-NA
  
  return(results)
}


##############################
###reject_outliers_method2, dataTemp and window_size as 20.
# we set the frequency as 2, once larger than 2, set NA
# return dataTemp (year, maxVal, and frequency)
Reject_outliers_method2 <- function(dataTemp,window_size,threshold_times) {
  
  maxVal <- dataTemp$maxVal
  
  rst <- list()
  for (i in 1:(length(maxVal)-window_size+1)) {
    cd <- maxVal[i:(i+window_size-1)]
    for (j in 1:window_size) {
      modified_list <- cd[-j]
      fit_gev <- fevd(modified_list)
      test<-fit_gev$results$par
      k<-qevd(0.99, loc =test[1] , scale = test[2], shape = test[3], type = c("GEV"))
      rst <- append(rst, k)}
    }
  
  sublist <- split(rst, rep(1:(length(maxVal)-window_size+1), each = window_size))
  converted_data <- lapply(sublist, function(sublist) as.numeric(unlist(sublist)))
  
  result <- lapply(converted_data, function(sublist) {
    # Convert sublist to a matrix or dist object
    sublist_matrix <- matrix(unlist(sublist), ncol = 1)  # Assuming each sublist is a column vector
  
    # Apply the LOF algorithm
    mlof <- lof(sublist_matrix, k = (window_size-1))
  
    # Determine the threshold
    thr <- quantile(mlof, 0.97)
  
    # Identify the outliers
    out_index <- which(mlof >= thr)
    })
  
  year_list<-dataTemp$year
  
  year_mw <- list()
  for (i in 1:(length(year_list) - window_size + 1)) {
    sublist <- year_list[i:(i + window_size - 1)]
    year_mw[[i]] <- sublist}

  get_values <- function(index_list_result, year_mw) {
    values <- year_mw[index_list_result]
    return(values)}
  
  # Apply the indexing operation for each pair of sublists in A and B
  result_1<- mapply(get_values,result, year_mw)
  counts <- table(result_1)
  
  # Sort the counts in descending order
  sorted_counts <- sort(counts, decreasing = TRUE)
  
  sorted_counts <- as.data.frame(sorted_counts)
  names(sorted_counts) <- c("year","frequency")
  
  dataTemp <- merge(dataTemp,sorted_counts,by="year",all = TRUE)

  dataTemp$maxVal[dataTemp$frequency > threshold_times] <- NA

  return(dataTemp)
}
```

-   **Discharge_at_GivenReturnPeriodandSamples**
Input: (dataTemp,window_size,return_periods)
return:discharges at return_100, return_10, (137 rows, 166, 30)
Note, you can pass raw_data or cleaned_data
```{r}
##############
###Discharge_at_GivenReturnPeriodandSamples: Moving_window to fit the curves
# Inputs:   dataTemp: year, maxVal, "r"; window_size = 30 or other value; return_periods = c(100, 10)
# output: discharges at_GivenReturnPeriodSamples 

#e.g., using data 166 years, get the (166-30+1) curves * n_return_periods
# (166-30+1)*n_return_periods, i.e., using 137 data_bin ---> curves --> the discharge values using difference curves and different return period.
# output: discharges at return_100, return_10, (137 rows, 166, 30)

Discharge_at_GivenReturnPeriodandSamples <- function(dataTemp,window_size,return_periods) {
  ret_list <- list()
  
  for (i in 1:(nrow(dataTemp)-window_size+1)){
    current_data <- dataTemp[i:(i+window_size-1), , drop=FALSE]
    current_data <- na.omit(current_data)
    fit_gev <- fevd(current_data$maxVal,current_data)
    temp <- return.level(fit_gev,return.period=return_periods)

    ret <- as.list(temp)
    ret_list <- append(ret_list, ret)    # 137*3=411
  }


  vec <- unlist(ret_list)
  df <- data.frame(Name = names(vec), Value = as.numeric(vec))


  df$rowid <- 1:nrow(df)
  df_wide <- dcast(df, rowid ~ Name, value.var = "Value")
  df_wide$rowid <- NULL

  new_cols <- list()
  for (col in names(df_wide)) {
    new_cols[[col]] <- na.omit(df_wide[[col]])}
  df <- do.call(data.frame, new_cols)
  
  colnames(df) <- colnames(df_wide)
  colnames(df) <- paste0("return_", colnames(df))
  
  return(df)
}
```

-   **flood extreme estimate with GAMLSS method**
output: data_second
```{r}
GamlssFigure1Data <- function(raw_data,baseyear){
  data_info <- fitted_infor_4models_4conditions(raw_data)
  
  model_summary <- data_info[, c('SBC_1_WEI', 'SBC_2_WEI','SBC_3_WEI','SBC_4_WEI','SBC_1_LOGNO',
                                 'SBC_2_LOGNO','SBC_3_LOGNO','SBC_4_LOGNO','SBC_1_GU','SBC_2_GU',
                                 'SBC_3_GU','SBC_4_GU','SBC_1_GA','SBC_2_GA','SBC_3_GA','SBC_4_GA')]
  
  model_summary <-  as.data.frame(model_summary)
  best_model_info <- names(which.min(model_summary[1, ]))
  variables <- strsplit(best_model_info, "_")[[1]]
  parameter_id <- as.numeric(variables[2])
  model_id <- variables[3]
  
  ### here we select that best model, its mu and sigma
  tt <- paste("data_second <- data_info[, c('year', 'maxVal',", 
              paste0("'mu_", parameter_id, "_", model_id, "', '", "sigma_", 
                     parameter_id, "_", model_id, "'", collapse = ", "), ")]", sep = "")
  
  eval(parse(text = tt))
  
  names(data_second) <- c("year","maxVal","mu","sigma")
  
  ### we get the discharge for each year at 20- 50- 100- return periods
  
  ### define the year 
  
  if(model_id == "GA"){
    data_second$flood_magnitude_100yr <- qGA(0.99, mu = data_second$mu, sigma = data_second$sigma)
    data_second$flood_magnitude_50yr <- qGA(0.98, mu = data_second$mu, sigma = data_second$sigma)
    data_second$flood_magnitude_20yr <- qGA(0.95, mu = data_second$mu, sigma = data_second$sigma)
    data_second$flood_magnitude_90th <- qGA(0.90, mu = data_second$mu, sigma = data_second$sigma)
    data_second$flood_magnitude_80th <- qGA(0.80, mu = data_second$mu, sigma = data_second$sigma)
    data_second$flood_magnitude_50th <- qGA(0.50, mu = data_second$mu, sigma = data_second$sigma)
    data_second$flood_magnitude_1_1yr <- qGA(0.01, mu = data_second$mu, sigma = data_second$sigma)
    
    ### select discharge at a given return period and in a reference year
    index = which(data_second$year==baseyear) 
  
    base_discharge_50yr <- data_second$flood_magnitude_50yr[index]
    base_discharge_100yr <- data_second$flood_magnitude_100yr[index]
    base_discharge_20yr <- data_second$flood_magnitude_20yr[index]
    
    data_second$return_period_at_100yr_discharge_in_reference_year <- 1/(1-pGA(base_discharge_100yr, mu = data_second$mu, 
                                                                               sigma = data_second$sigma))
    data_second$return_period_at_50yr_discharge_in_reference_year <- 1/(1-pGA(base_discharge_50yr, mu = data_second$mu, 
                                                                              sigma = data_second$sigma))
    data_second$return_period_at_20yr_discharge_in_reference_year <- 1/(1-pGA(base_discharge_20yr, mu = data_second$mu, 
                                                                              sigma = data_second$sigma))
  }else if (model_id == "GU"){
      data_second$flood_magnitude_100yr <- qGU(0.99, mu = data_second$mu, sigma = data_second$sigma)
      data_second$flood_magnitude_50yr <- qGU(0.98, mu = data_second$mu, sigma = data_second$sigma)
      data_second$flood_magnitude_20yr <- qGU(0.95, mu = data_second$mu, sigma = data_second$sigma)
      data_second$flood_magnitude_90th <- qGU(0.90, mu = data_second$mu, sigma = data_second$sigma)
      data_second$flood_magnitude_80th <- qGU(0.80, mu = data_second$mu, sigma = data_second$sigma)
      data_second$flood_magnitude_50th <- qGU(0.50, mu = data_second$mu, sigma = data_second$sigma)
      data_second$flood_magnitude_1_1yr <- qGU(0.01, mu = data_second$mu, sigma = data_second$sigma)
  
      ### select discharge at a given return period and in a reference year
      index = which(data_second$year==baseyear) #### you may change the year here!!!!!
  
      base_discharge_50yr <- data_second$flood_magnitude_50yr[index]
      base_discharge_100yr <- data_second$flood_magnitude_100yr[index]
      base_discharge_20yr <- data_second$flood_magnitude_20yr[index]
    
      data_second$return_period_at_100yr_discharge_in_reference_year <- 1/(1-pGU(base_discharge_100yr, mu = data_second$mu, 
                                                                               sigma = data_second$sigma))
      data_second$return_period_at_50yr_discharge_in_reference_year <- 1/(1-pGU(base_discharge_50yr, mu = data_second$mu, 
                                                                              sigma = data_second$sigma))
      data_second$return_period_at_20yr_discharge_in_reference_year <- 1/(1-pGU(base_discharge_20yr, mu = data_second$mu, 
                                                                              sigma = data_second$sigma))
  }else if (model_id == "WEI"){
      data_second$flood_magnitude_100yr <- qWEI(0.99, mu = data_second$mu, sigma = data_second$sigma)
      data_second$flood_magnitude_50yr <- qWEI(0.98, mu = data_second$mu, sigma = data_second$sigma)
      data_second$flood_magnitude_20yr <- qWEI(0.95, mu = data_second$mu, sigma = data_second$sigma)
      data_second$flood_magnitude_90th <- qWEI(0.90, mu = data_second$mu, sigma = data_second$sigma)
      data_second$flood_magnitude_80th <- qWEI(0.80, mu = data_second$mu, sigma = data_second$sigma)
      data_second$flood_magnitude_50th <- qWEI(0.50, mu = data_second$mu, sigma = data_second$sigma)
      data_second$flood_magnitude_1_1yr <- qWEI(0.01, mu = data_second$mu, sigma = data_second$sigma)
  
      ### select discharge at a given return period and in a reference year
      index = which(data_second$year==baseyear) #### you may change the year here!!!!!
  
      base_discharge_50yr <- data_second$flood_magnitude_50yr[index]
      base_discharge_100yr <- data_second$flood_magnitude_100yr[index]
      base_discharge_20yr <- data_second$flood_magnitude_20yr[index]

  
      data_second$return_period_at_100yr_discharge_in_reference_year <- 1/(1-pWEI(base_discharge_100yr, 
                                                                                  mu = data_second$mu, sigma = data_second$sigma))
      data_second$return_period_at_50yr_discharge_in_reference_year <- 1/(1-pWEI(base_discharge_50yr,
                                                                                 mu = data_second$mu, sigma = data_second$sigma))
      data_second$return_period_at_20yr_discharge_in_reference_year <- 1/(1-pWEI(base_discharge_20yr, 
                                                                                 mu = data_second$mu, sigma = data_second$sigma))
    }else if (model_id == "LOGNO"){
      data_second$flood_magnitude_100yr <- qLOGNO(0.99, mu = data_second$mu, sigma = data_second$sigma)
      data_second$flood_magnitude_50yr <- qLOGNO(0.98, mu = data_second$mu, sigma = data_second$sigma)
      data_second$flood_magnitude_20yr <- qLOGNO(0.95, mu = data_second$mu, sigma = data_second$sigma)
      data_second$flood_magnitude_90th <- qLOGNO(0.90, mu = data_second$mu, sigma = data_second$sigma)
      data_second$flood_magnitude_80th <- qLOGNO(0.80, mu = data_second$mu, sigma = data_second$sigma)
      data_second$flood_magnitude_50th <- qLOGNO(0.50, mu = data_second$mu, sigma = data_second$sigma)
      data_second$flood_magnitude_1_1yr <- qLOGNO(0.01, mu = data_second$mu, sigma = data_second$sigma)
  
      ### select discharge at a given return period and in a reference year
      index = which(data_second$year==baseyear) #### you may change the year here!!!!!
  
      base_discharge_50yr <- data_second$flood_magnitude_50yr[index]
      base_discharge_100yr <- data_second$flood_magnitude_100yr[index]
      base_discharge_20yr <- data_second$flood_magnitude_20yr[index]

  
      data_second$return_period_at_100yr_discharge_in_reference_year <- 1/(1-pLOGNO(base_discharge_100yr, 
                                                                                    mu = data_second$mu, sigma = data_second$sigma))
      data_second$return_period_at_50yr_discharge_in_reference_year <- 1/(1-pLOGNO(base_discharge_50yr, 
                                                                                   mu = data_second$mu, sigma = data_second$sigma))
      data_second$return_period_at_20yr_discharge_in_reference_year <- 1/(1-pLOGNO(base_discharge_20yr,
                                                                                   mu = data_second$mu, sigma = data_second$sigma))
  
  }

return(data_second)
}
```

-   **Generating synthetic data with Non-stationary GEV model**
Please see the examples for using it.
```{r}
########################
###Generating synthetic data with Non-stationary GEV model
# exp1 changing location
syntheticData_changingLocation <- function(location,scale,shape,
                                           upper_coe,down_coe,b0_coe,
                                           Type,raw_data,changingPoint,changingPoint_1,changingPoint_2,b1_coe,b2_coe) {
  
  qcov<- raw_data$year
  
  # check the initial_location, scale, and shape value.
  if(location<0 ||scale<0){
    print("GEV parameters should be postive!")
    return(0)
  }
  if(scale>0.5*location){
    print("Scale is too large compared to location, Please reset!")
    return(0)
  }
  
  upperboudary <- upper_coe*location
  downboundary <- down_coe*location
  
  # Choose the type for generating fake data
  if(Type=="Linear"){
    # y=bx+b0
    bmax <- (upperboudary-downboundary)/(length(qcov)-1)
    b <- b0_coe*bmax
    
    locations <- (qcov-min(qcov))*b+downboundary
    random_numbers <- rgev(n = length(qcov), loc = locations, scale = scale, shape = shape)
    return_level<-qgev(0.99, loc = locations, scale = scale, shape = shape, lower.tail = TRUE)
    
  }else if(Type=="Power"){
    # y=bx^2+b0
    bmax <- (upperboudary-downboundary)/((length(qcov)-1)^2)
    b <- b0_coe*bmax
    locations <- ((qcov-min(qcov))^2)*b+downboundary
    random_numbers <- rgev(n = length(qcov), loc = locations, scale = scale, shape = shape)
    return_level<-qgev(0.99, loc = locations, scale = scale, shape = shape,
                       lower.tail = TRUE)
  }else if(Type=="Partial"){
    # y=bx+b0 - y=bx+b0
    bmax <- (upperboudary-downboundary)/(length(qcov)-1)
    b1 <- b1_coe*bmax
    b2 <- b2_coe*bmax
    locations_1 <- (qcov-min(qcov))*b1+downboundary
    locations_2 <- (qcov-min(qcov))*b2+downboundary
    locations <- c(locations_1[1:changingPoint],locations_2[(changingPoint+1):length(qcov)])
    random_numbers <- rgev(n = length(qcov), loc = locations, scale = scale, shape = shape)
    return_level<-qgev(0.99, loc = locations, scale = scale, shape = shape, lower.tail = TRUE)
    
  }else if(Type=="Partial_1"){
    # y=bx+b0 - y=bx+b0
    bmax <- (upperboudary-downboundary)/(length(qcov)-1)
    b1 <- b1_coe*bmax
    b2 <- b2_coe*bmax
    b3 <- b2_coe*(-bmax)
    
    locations_1 <- (qcov-min(qcov))*b1+downboundary
    locations_2 <- (qcov-min(qcov))*b2+downboundary
    locations_3 <-(qcov-min(qcov))*b3+downboundary
    
    locations <- c(locations_1[1:changingPoint_1],locations_3[(changingPoint_1+1):changingPoint_2],locations_2[(changingPoint_2+1):length(qcov)])
    random_numbers <- rgev(n = length(qcov), loc = locations, scale = scale, shape = shape)
    return_level<-qgev(0.99, loc = locations, scale = scale, shape = shape, lower.tail = TRUE)
    
  }
  # result<-random_numbers
  final_result <- data.frame(random_numbers = random_numbers,
                             return_level = return_level,
                             location = locations,
                             scale = scale,
                             shape = shape)
  return(final_result)
}



########################
# exp2 changing scale
syntheticData_changingScale <- function(location,scale,shape,
                                        upper_coe,down_coe,b0_coe,
                                        Type,raw_data,changingPoint,changingPoint_1,changingPoint_2,b1_coe,b2_coe) {
  
  qcov<- raw_data$year
  
  # check the initial_location, scale, and shape value.
  if(location<0 ||scale<0){
    print("GEV parameters should be postive!")
    return(0)
  }
  if(scale>0.5*location||scale<0.02*location){
    print("Scale is too large or too small compared to location, Please reset!")
    return(0)
  }
  
  upperboudary <- upper_coe*scale
  downboundary <- down_coe*scale
  
  # Choose the type for generating fake data
  if(Type=="Linear"){
    # y=bx+b0
    bmax <- (upperboudary-downboundary)/(length(qcov)-1)
    b <- b0_coe*bmax
    
    scales <- (qcov-min(qcov))*b+downboundary
    random_numbers <- rgev(n = length(qcov), loc = location, scale = scales, shape = shape)
    return_level<-qgev(0.99, loc = location, scale = scales, shape = shape, lower.tail = TRUE)
    # infoLine <- trendline_sum(seq(1,length(random_numbers_1)),random_numbers_1)
    # infoLine$parameter$a
  }else if(Type=="Power"){
    # y=bx^2+b0
    bmax <- (upperboudary-downboundary)/((length(qcov)-1)^2)
    b <- b0_coe*bmax
    scales <- ((qcov-min(qcov))^2)*b+downboundary
    random_numbers <- rgev(n = length(qcov), loc = location, scale = scales, shape = shape)
    return_level<-qgev(0.99, loc = location, scale = scales, shape = shape,lower.tail = TRUE)
  }else if(Type=="Partial"){
    # y=bx+b0 - y=bx+b0
    bmax <- (upperboudary-downboundary)/(length(qcov)-1)
    b1 <- b1_coe*bmax
    b2 <- b2_coe*bmax
    scales_1 <- (qcov-min(qcov))*b1+downboundary
    scales_2 <- (qcov-min(qcov))*b2+downboundary
    scales <- c(scales_1[1:changingPoint],scales_2[(changingPoint+1):length(qcov)])
    random_numbers <- rgev(n = length(qcov), loc = location, scale = scales, shape = shape)
    return_level<-qgev(0.99, loc = location, scale = scales, shape = shape,lower.tail = TRUE)
  }else if(Type=="Partial_1"){
    # y=bx+b0 - y=bx+b0
    bmax <- (upperboudary-downboundary)/(length(qcov)-1)
    b1 <- b1_coe*bmax
    b2 <- b2_coe*bmax
    b3 <- b2_coe*(-bmax)
    
    scales_1 <- (qcov-min(qcov))*b1+downboundary
    scales_2 <- (qcov-min(qcov))*b2+downboundary
    scales_3 <-(qcov-min(qcov))*b3+downboundary
    
    scales <- c(scales_1[1:changingPoint_1],scales_3[(changingPoint_1+1):changingPoint_2],scales_2[(changingPoint_2+1):length(qcov)])
    random_numbers <- rgev(n = length(qcov), loc = location, scale = scales, shape = shape)
    return_level<-qgev(0.99, loc = location, scale = scales, shape = shape, lower.tail = TRUE)
    
  }
  final_result <- data.frame(random_numbers = random_numbers,
                             return_level = return_level,
                             location = location,
                             scale = scales,
                             shape = shape)
  return(final_result)
}

########################
# exp3 changing location and scale
syntheticData_changingLocationscale <- function(location,scale,shape,
                                                upper_coe,down_coe,b0_coe, upper_coe_1,down_coe_1,
                                                Type,raw_data,changingPoint,changingPoint_1,changingPoint_2,b1_coe,b2_coe) {
  
  qcov<- raw_data$year
  
  # check the initial_location, scale, and shape value.
  if(location<0){
    print("GEV parameters should be postive!")
    return(0)
  }
  if(scale>0.5*location){
    print("Scale is too large compared to location, Please reset!")
    return(0)
  }
  
  upperboudary <- upper_coe*location
  downboundary <- down_coe*location
  
  # Choose the type for generating fake data
  if(Type=="Linear"){
    # y=bx+b0
    bmax <- (upperboudary-downboundary)/(length(qcov)-1)
    b <- b0_coe*bmax
    locations <- (qcov-min(qcov))*b+downboundary
    
    new_location<-mean(locations)
    upperboudary_1<- upper_coe_1*new_location 
    downboundary_1<- down_coe_1*new_location
    bmax_1<-(upperboudary_1-downboundary_1)/(length(qcov)-1)
    b_1 <- b0_coe*bmax_1
    scales<- (qcov-min(qcov))*b_1+downboundary_1
    
    random_numbers <- rgev(n = length(qcov), loc = locations, scale = scales, shape = shape)
    return_level<-qgev(0.99, loc = locations, scale = scales, shape = shape,
                       lower.tail = TRUE)
  }else if(Type=="Power"){
    # y=bx^2+b0
    bmax <- (upperboudary-downboundary)/((length(qcov)-1)^2)
    b <- b0_coe*bmax
    locations <- ((qcov-min(qcov))^2)*b+downboundary
    
    new_location<-mean(locations)
    upperboudary_1<- upper_coe_1*new_location 
    downboundary_1<- down_coe_1*new_location
    bmax_1<-(upperboudary_1-downboundary_1)/((length(qcov)-1)^2)
    b_1 <- b0_coe*bmax_1
    scales<- ((qcov-min(qcov))^2)*b_1+downboundary_1
    
    random_numbers <- rgev(n = length(qcov), loc = locations, scale = scales, shape = shape)
    return_level<-qgev(0.99, loc = locations, scale = scales, shape = shape,
                       lower.tail = TRUE)
  }else if(Type=="Partial"){
    # y=bx+b0 - y=bx+b0
    bmax <- (upperboudary-downboundary)/(length(qcov)-1)
    b1 <- b1_coe*bmax
    locations_1 <- (qcov-min(qcov))*b1+downboundary
    new_location_1<-mean(locations_1)
    
    upperboudary_1<- upper_coe_1*new_location_1 
    downboundary_1<- down_coe_1*new_location_1
    
    bmax_1<-(upperboudary_1-downboundary_1)/(length(qcov)-1)
    b_1 <- b0_coe*bmax_1
    scale_1<- (qcov-min(qcov))*b_1+downboundary_1
    
    
    b2 <- b2_coe*bmax
    locations_2 <- (qcov-min(qcov))*b2+downboundary
    new_location_2<-mean(locations_2)
    upperboudary_2<- upper_coe_1*new_location_2 
    downboundary_2<- down_coe_1*new_location_2
    bmax_2<-(upperboudary_2-downboundary_2)/(length(qcov)-1)
    b_2 <- b0_coe*bmax_2
    scale_2<- (qcov-min(qcov))*b_2+downboundary_2
    
    locations <- c(locations_1[1:changingPoint],locations_2[(changingPoint+1):length(qcov)])
    scales <- c(scale_1[1:changingPoint],scale_2[(changingPoint+1):length(qcov)])
    
    random_numbers <- rgev(n = length(qcov), loc = locations, scale = scales, shape = shape)
    return_level<-qgev(0.99, loc = locations, scale = scales, shape = shape,
                       lower.tail = TRUE)
    
  }else if(Type=="Partial_1"){
    # y=bx+b0 - y=bx+b0
    bmax <- (upperboudary-downboundary)/(length(qcov)-1)
    b1 <- b1_coe*bmax
    locations_1 <- (qcov-min(qcov))*b1+downboundary
    new_location_1<-mean(locations_1)
    
    upperboudary_1<- upper_coe_1*new_location_1 
    downboundary_1<- down_coe_1*new_location_1
    
    bmax_1<-(upperboudary_1-downboundary_1)/(length(qcov)-1)
    b_1 <- b0_coe*bmax_1
    scale_1<- (qcov-min(qcov))*b_1+downboundary_1
    
    
    b2 <- b2_coe*bmax
    locations_2 <- (qcov-min(qcov))*b2+downboundary
    new_location_2<-mean(locations_2)
    upperboudary_2<- upper_coe_1*new_location_2 
    downboundary_2<- down_coe_1*new_location_2
    bmax_2<-(upperboudary_2-downboundary_2)/(length(qcov)-1)
    b_2 <- b0_coe*bmax_2
    scale_2<- (qcov-min(qcov))*b_2+downboundary_2
    
    b3<-(b1_coe+b2_coe)/2*(-bmax)
    # b3<-b1_coe*(-bmax)
    locations_3 <-(qcov-min(qcov))*b3+downboundary
    new_location_3<-mean(locations_3)
    upperboudary_3<- upper_coe_1*new_location_3 
    downboundary_3<- down_coe_1*new_location_3
    bmax_3<-(upperboudary_3-downboundary_3)/(length(qcov)-1)
    b_3 <- b0_coe*(-bmax_1)
    scale_3<- (qcov-min(qcov))*b_3+downboundary_3
    
    
    locations <- c(locations_1[1:changingPoint_1],locations_3[(changingPoint_1+1):changingPoint_2],locations_2[(changingPoint_2+1):length(qcov)])
    scales <- c(scale_1[1:changingPoint_1],scale_3[(changingPoint_1+1):changingPoint_2],scale_2[(changingPoint_2+1):length(qcov)])
    
    random_numbers <- rgev(n = length(qcov), loc = locations, scale = scales, shape = shape)
    return_level<-qgev(0.99, loc = locations, scale = scales, shape = shape, lower.tail = TRUE)
    
  }
  final_result <- data.frame(random_numbers = random_numbers,
                             return_level = return_level,
                             location = locations,
                             scale = scales,
                             shape = shape)
  return(final_result)
}
```

# **Test run**
-   **To generate the sample data for plotting**
You run the code below, then, run the code in the f01-figureA1.R to show
the generation process (three figures.)
```{r}
###########
#Note, we slightly changed the function of generating synthetic data, particularly for the piecewise function that can generate time series with decreasing trend. So, please refer to our R codes. 

### figure 1
inital_location <- 3000
inital_scale <- 900
inital_shape <- 0.15

upper_coe_loc <- 1.5
down_coe_loc <- 0.8


b0_coefficients <- c(1,1/2,1/3)

b1_coefficients <- c(1/3,1/4,1/5)
b2_coefficients <- c(1,1/3,1/2)

years <- data.frame(year = seq(1850,2015))

for (i in 1:3){
  data_loc <- syntheticData_changingLocation(location=inital_location,scale=inital_scale,shape=inital_shape,
                                             upper_coe=upper_coe_loc,down_coe=down_coe_loc,
                                             b0_coe=b0_coefficients[i],Type="Linear",
                                             raw_data=years,changingPoint=7,b1_coe=1,b2_coe=1)
  
  ttt <- paste0("data_loc_linear_",i, "<-data_loc")
  eval(parse(text=ttt))
  
  data_loc <- syntheticData_changingLocation(location=inital_location,scale=inital_scale,shape=inital_shape,
                                             upper_coe=upper_coe_loc,down_coe=down_coe_loc,
                                             b0_coe=b0_coefficients[i],Type="Power",
                                             raw_data=years,changingPoint=7,b1_coe=1,b2_coe=1)
  
  ttt <- paste0("data_loc_power_",i, "=data_loc")
  eval(parse(text=ttt))
  
  data_loc <- syntheticData_changingLocation(location=inital_location,scale=inital_scale,shape=inital_shape,
                                             upper_coe=upper_coe_loc,down_coe=down_coe_loc,
                                             b0_coe=b0_coefficients[i],Type="Partial",
                                             raw_data=years,changingPoint=80,
                                             b1_coe=b1_coefficients[i],
                                             b2_coe=b2_coefficients[i])
  
  ttt <- paste0("data_loc_partial_",i, "=data_loc")
  eval(parse(text=ttt))
  
  
}



### figure 2

inital_location <- 3000
inital_scale <- 900
inital_shape <- 0.15

upper_coe_loc <- 1.1
down_coe_loc <- 0.9


b0_coefficients <- c(1,1/2,1/3)

b1_coefficients <- c(1/3,1/4,1/5)
b2_coefficients <- c(1,1/3,1/2)

for (i in 1:3){
  data_loc <- syntheticData_changingScale(location=inital_location,scale=inital_scale,shape=inital_shape,
                                             upper_coe=upper_coe_loc,down_coe=down_coe_loc,
                                             b0_coe=b0_coefficients[i],Type="Linear",
                                             raw_data=years,changingPoint=7,b1_coe=1,b2_coe=1)
  
  ttt <- paste0("data_sca_linear_",i, "<-data_loc")
  eval(parse(text=ttt))
  
  data_loc <- syntheticData_changingScale(location=inital_location,scale=inital_scale,shape=inital_shape,
                                             upper_coe=upper_coe_loc,down_coe=down_coe_loc,
                                             b0_coe=b0_coefficients[i],Type="Power",
                                             raw_data=years,changingPoint=7,b1_coe=1,b2_coe=1)
  
  ttt <- paste0("data_sca_power_",i, "=data_loc")
  eval(parse(text=ttt))
  
  data_loc <- syntheticData_changingScale(location=inital_location,scale=inital_scale,shape=inital_shape,
                                             upper_coe=upper_coe_loc,down_coe=down_coe_loc,
                                             b0_coe=b0_coefficients[i],Type="Partial",
                                             raw_data=years,changingPoint=80,
                                             b1_coe=b1_coefficients[i],
                                             b2_coe=b2_coefficients[i])
  
  ttt <- paste0("data_sca_partial_",i, "=data_loc")
  eval(parse(text=ttt))
  
  
}



### figure 3
  

inital_location <- 3000
inital_scale <- 900
inital_shape <- 0.15

upper_coe_loc <- 1.5
down_coe_loc <- 0.8

upper_coe_sca <- 0.4
down_coe_sca <- 0.2


b0_coefficients <- c(1,1/2,1/3)

b1_coefficients <- c(1/3,1/4,1/5)
b2_coefficients <- c(1,1/3,1/2)


for (i in 1:3){
  data_loc <- syntheticData_changingLocationscale(location=inital_location,scale=inital_scale,shape=inital_shape,
                                             upper_coe=upper_coe_loc,down_coe=down_coe_loc,
                                             b0_coe=b0_coefficients[i],upper_coe_1=upper_coe_sca,
                                          down_coe_1=down_coe_sca, Type="Linear",
                                             raw_data=years,changingPoint=100,b1_coe=1,b2_coe=1)
  
  ttt <- paste0("data_locsca_linear_",i, "<-data_loc")
  eval(parse(text=ttt))
  
  data_loc <- syntheticData_changingLocationscale(location=inital_location,scale=inital_scale,shape=inital_shape,
                                             upper_coe=upper_coe_loc,down_coe=down_coe_loc,
                                             b0_coe=b0_coefficients[i],upper_coe_1=upper_coe_sca,
                                          down_coe_1=down_coe_sca, Type="Power",
                                             raw_data=years,changingPoint=100,b1_coe=1,b2_coe=1)
  
  ttt <- paste0("data_locsca_power_",i, "=data_loc")
  eval(parse(text=ttt))
  
  data_loc <- syntheticData_changingLocationscale(location=inital_location,scale=inital_scale,shape=inital_shape,
                                             upper_coe=upper_coe_loc,down_coe=down_coe_loc,
                                             b0_coe=b0_coefficients[i],upper_coe_1=upper_coe_sca,
                                          down_coe_1=down_coe_sca, Type="Partial",
                                             raw_data=years,changingPoint=100,
                                             b1_coe=b1_coefficients[i],
                                             b2_coe=b2_coefficients[i])
  
  ttt <- paste0("data_locsca_partial_",i, "=data_loc")
  eval(parse(text=ttt))
  
}
rm(data_loc,years)
```

-   **plot the figure to show our generated data**
```{r}
#######---Figure 1
inital_location <- 3000
inital_scale <- 900
inital_shape <- 0.15

upper_coe_loc <- 1.5
down_coe_loc <- 0.8
qcov <- seq(1850,2015)


b0_coefficients <- c(1,1/2,1/3)

b1_coefficients <- c(1/3,1/4,1/5)
b2_coefficients <- c(1,1/3,1/2)

downboundary <- down_coe_loc*inital_location
upperboudary <- upper_coe_loc*inital_location
b <- (upperboudary-downboundary)/(length(qcov)-1)
bmax<-(upperboudary-downboundary)/((length(qcov)-1)^2)

locations1<-data_loc_linear_1$location
locations2<-data_loc_linear_2$location
locations3<-data_loc_linear_3$location
random_numbers1<-data_loc_linear_1$random_numbers
random_numbers2<-data_loc_linear_2$random_numbers
random_numbers3<-data_loc_linear_3$random_numbers



locations4<-data_loc_power_1$location
locations5<-data_loc_power_2$location
locations6<-data_loc_power_3$location
random_numbers4<-data_loc_power_1$random_numbers
random_numbers5<-data_loc_power_2$random_numbers
random_numbers6<-data_loc_power_3$random_numbers


locations7<-data_loc_partial_1$location
locations8<-data_loc_partial_2$location
locations9<-data_loc_partial_3$location
random_numbers7<-data_loc_partial_1$random_numbers
random_numbers8<-data_loc_partial_2$random_numbers
random_numbers9<-data_loc_partial_3$random_numbers


#### plot
par(mfrow = c(1, 2), mar = c(5, 4, 4, 2) + 0.1, oma = c(1, 2, 2, 0))
par(las = 0, font.main = 2, cex.main = 1)


col <- adjustcolor("grey", alpha = 0.2)

plot(locations1, ylim = c(downboundary, upperboudary), pch = 16, col = "grey",main = paste0("location=", round(down_coe_loc*inital_location,digits=0), "+", round(b0_coefficients[1]*b,digits=2), "*t"), xlab = "t", ylab = "Location")

rect(par("usr")[1], downboundary, par("usr")[2], upperboudary, col = col, border = NA)
segments(0, downboundary, 166, upperboudary, col = "black",lwd=1, lty = 2)
plot(random_numbers1,  xlab = "t", ylab = "Discharge (m3/s)", xlim = c(0, 166))


plot(locations4, ylim = c(downboundary, upperboudary), pch = 16, col = "grey",main = paste0("location=", round(down_coe_loc*inital_location,digits=0), "+", round(b0_coefficients[1]*bmax,digits=2), "*t*t"), xlab = "t", ylab = "Location")
rect(par("usr")[1], downboundary, par("usr")[2], upperboudary, col = col, border = NA)
segments(0, downboundary, 166, upperboudary, col = "black",lwd=1, lty = 2)
plot(random_numbers4, xlab = "t", ylab = "Discharge (m3/s)")

# 
# 
# plot(locations7, ylim = c(downboundary, upperboudary), pch = 16, col = "grey",main = paste0("b1=", round(b1_coefficients[1]*b,digits=2), ", b2=", round(b2_coefficients[1]*b,digits=2)), xlab = "t", ylab = "Location")
# rect(par("usr")[1], downboundary, par("usr")[2], upperboudary, col = col, border = NA)
# segments(0, downboundary, 166, upperboudary, col = "black",lwd=1, lty = 2)
# plot(random_numbers7, xlab = "t", ylab = "Discharge (m3/s)")
# 
# 
# 
# 
# plot(locations2, ylim = c(downboundary, upperboudary), pch = 16, col = "grey",main = paste0("location=", round(down_coe_loc*inital_location,digits=0), "+", round(b0_coefficients[2]*b,digits=2), "*t"), xlab = "t", ylab = "Location")
# rect(par("usr")[1], downboundary, par("usr")[2], upperboudary, col = col, border = NA)
# segments(0, downboundary, 166, upperboudary, col = "black",lwd=1, lty = 2)
# plot(random_numbers2, xlab = "t", ylab = "Discharge (m3/s)")
# 
# 
# plot(locations5, ylim = c(downboundary, upperboudary), pch = 16, col = "grey",main = paste0("location=", round(down_coe_loc*inital_location,digits=0), "+", round(b0_coefficients[2]*bmax,digits=2), "*t*t"), xlab = "t", ylab = "Location")
# rect(par("usr")[1], downboundary, par("usr")[2], upperboudary, col = col, border = NA)
# segments(0, downboundary, 166, upperboudary, col = "black",lwd=1, lty = 2)
# plot(random_numbers5, xlab = "t", ylab = "Discharge (m3/s)")
# 
# 
# 
# plot(locations8, ylim = c(downboundary, upperboudary), pch = 16, col = "grey",main = paste0("b1=", round(b1_coefficients[2]*b,digits=2), ", b2=", round(b2_coefficients[2]*b,digits=2)), xlab = "t", ylab = "Location")
# rect(par("usr")[1], downboundary, par("usr")[2], upperboudary, col = col, border = NA)
# segments(0, downboundary, 166, upperboudary, col = "black",lwd=1, lty = 2)
# plot(random_numbers8, xlab = "t", ylab = "Discharge (m3/s)")
# 
# 
# 
# plot(locations3, ylim = c(downboundary, upperboudary), pch = 16, col = "grey",main = paste0("location=", round(down_coe_loc*inital_location,digits=0), "+", round(b0_coefficients[3]*b,digits=2), "*t"), xlab = "t", ylab = "Location")
# rect(par("usr")[1], downboundary, par("usr")[2], upperboudary, col = col, border = NA)
# segments(0, downboundary, 166, upperboudary, col = "black",lwd=1, lty = 2)
# plot(random_numbers3, xlab = "t", ylab = "Discharge (m3/s)")
# 
# 
# 
# plot(locations6, ylim = c(downboundary, upperboudary), pch = 16, col = "grey",main = paste0("location=", round(down_coe_loc*inital_location,digits=0), "+", round(b0_coefficients[3]*bmax,digits=2), "*t*t"), xlab = "t", ylab = "Location")
# rect(par("usr")[1], downboundary, par("usr")[2], upperboudary, col = col, border = NA)
# segments(0, downboundary, 166, upperboudary, col = "black",lwd=1, lty = 2)
# plot(random_numbers6, xlab = "t", ylab = "Discharge (m3/s)")
# 
# 
# plot(locations9, ylim = c(downboundary, upperboudary), pch = 16, col = "grey",main = paste0("b1=", round(b1_coefficients[3]*b,digits=2), ", b2=", round(b2_coefficients[3]*b,digits=2)), xlab = "t", ylab = "Location")
# rect(par("usr")[1], downboundary, par("usr")[2], upperboudary, col = col, border = NA)
# segments(0, downboundary, 166, upperboudary, col = "black",lwd=1, lty = 2)
# plot(random_numbers9, xlab = "t", ylab = "Discharge (m3/s)")
# 
# 
# 
# 
# 
# #######---Figure 2
# 
# 
# inital_location <- 3000
# inital_scale <- 900
# inital_shape <- 0.15
# 
# upper_coe_loc <- 1.1
# down_coe_loc <- 0.9
# 
# 
# b0_coefficients <- c(1,1/2,1/3)
# 
# b1_coefficients <- c(1/3,1/4,1/5)
# b2_coefficients <- c(1,1/3,1/2)
# 
# downboundary <- down_coe_loc*inital_scale
# upperboudary <- upper_coe_loc*inital_scale
# b <- (upperboudary-downboundary)/(length(qcov)-1)
# bmax<-(upperboudary-downboundary)/((length(qcov)-1)^2)
# 
# locations1<-data_sca_linear_1$scale
# locations2<-data_sca_linear_2$scale
# locations3<-data_sca_linear_3$scale
# random_numbers1<-data_sca_linear_1$random_numbers
# random_numbers2<-data_sca_linear_2$random_numbers
# random_numbers3<-data_sca_linear_3$random_numbers
# 
# 
# 
# locations4<-data_sca_power_1$scale
# locations5<-data_sca_power_2$scale
# locations6<-data_sca_power_3$scale
# random_numbers4<-data_sca_power_1$random_numbers
# random_numbers5<-data_sca_power_2$random_numbers
# random_numbers6<-data_sca_power_3$random_numbers
# 
# 
# locations7<-data_sca_partial_1$scale
# locations8<-data_sca_partial_2$scale
# locations9<-data_sca_partial_3$scale
# random_numbers7<-data_sca_partial_1$random_numbers
# random_numbers8<-data_sca_partial_2$random_numbers
# random_numbers9<-data_sca_partial_3$random_numbers
# 
# 
# #### plot
# par(mfrow = c(1, 2), mar = c(5, 4, 4, 2) + 0.1, oma = c(0, 0, 0, 0))
# par(las = 0, font.main = 2, cex.main = 1)
# 
# 
# col <- adjustcolor("grey", alpha = 0.2)
# 
# plot(locations1, ylim = c(downboundary, upperboudary), pch = 16, col = "grey",main = paste0("scale=", round(down_coe_loc*inital_scale,digits=0), "+", round(b0_coefficients[1]*b,digits=2), "*t"), xlab = "t", ylab = "Scale")
# 
# rect(par("usr")[1], downboundary, par("usr")[2], upperboudary, col = col, border = NA)
# segments(0, downboundary, 166, upperboudary, col = "black",lwd=1, lty = 2)
# plot(random_numbers1,  xlab = "t", ylab = "Discharge (m3/s)", xlim = c(0, 166))
# 
# 
# plot(locations4, ylim = c(downboundary, upperboudary), pch = 16, col = "grey",main = paste0("scale=", round(down_coe_loc*inital_scale,digits=0), "+", round(b0_coefficients[1]*bmax,digits=3), "*t*t"), xlab = "t", ylab = "Scale")
# rect(par("usr")[1], downboundary, par("usr")[2], upperboudary, col = col, border = NA)
# segments(0, downboundary, 166, upperboudary, col = "black",lwd=1, lty = 2)
# plot(random_numbers4, xlab = "t", ylab = "Discharge (m3/s)")
# 
# 
# 
# plot(locations7, ylim = c(downboundary, upperboudary), pch = 16, col = "grey",main = paste0("b1=", round(b1_coefficients[1]*b,digits=2), ", b2=", round(b2_coefficients[1]*b,digits=2)), xlab = "t", ylab = "Scale")
# rect(par("usr")[1], downboundary, par("usr")[2], upperboudary, col = col, border = NA)
# segments(0, downboundary, 166, upperboudary, col = "black",lwd=1, lty = 2)
# plot(random_numbers7, xlab = "t", ylab = "Discharge (m3/s)")
# 
# 
# 
# 
# plot(locations2, ylim = c(downboundary, upperboudary), pch = 16, col = "grey",main = paste0("scale=", round(down_coe_loc*inital_scale,digits=0), "+", round(b0_coefficients[2]*b,digits=2), "*t"), xlab = "t", ylab = "Scale")
# rect(par("usr")[1], downboundary, par("usr")[2], upperboudary, col = col, border = NA)
# segments(0, downboundary, 166, upperboudary, col = "black",lwd=1, lty = 2)
# plot(random_numbers2, xlab = "t", ylab = "Discharge (m3/s)")
# 
# 
# plot(locations5, ylim = c(downboundary, upperboudary), pch = 16, col = "grey",main = paste0("scale=", round(down_coe_loc*inital_scale,digits=0), "+", round(b0_coefficients[2]*bmax,digits=3), "*t*t"), xlab = "t", ylab = "Scale")
# rect(par("usr")[1], downboundary, par("usr")[2], upperboudary, col = col, border = NA)
# segments(0, downboundary, 166, upperboudary, col = "black",lwd=1, lty = 2)
# plot(random_numbers5, xlab = "t", ylab = "Discharge (m3/s)")
# 
# 
# 
# plot(locations8, ylim = c(downboundary, upperboudary), pch = 16, col = "grey",main = paste0("b1=", round(b1_coefficients[2]*b,digits=2), ", b2=", round(b2_coefficients[2]*b,digits=2)), xlab = "t", ylab = "Scale")
# rect(par("usr")[1], downboundary, par("usr")[2], upperboudary, col = col, border = NA)
# segments(0, downboundary, 166, upperboudary, col = "black",lwd=1, lty = 2)
# plot(random_numbers8, xlab = "t", ylab = "Discharge (m3/s)")
# 
# 
# 
# plot(locations3, ylim = c(downboundary, upperboudary), pch = 16, col = "grey",main = paste0("scale=", round(down_coe_loc*inital_scale,digits=0), "+", round(b0_coefficients[3]*b,digits=2), "*t"), xlab = "t", ylab = "Scale")
# rect(par("usr")[1], downboundary, par("usr")[2], upperboudary, col = col, border = NA)
# segments(0, downboundary, 166, upperboudary, col = "black",lwd=1, lty = 2)
# plot(random_numbers3, xlab = "t", ylab = "Discharge (m3/s)")
# 
# 
# 
# plot(locations6, ylim = c(downboundary, upperboudary), pch = 16, col = "grey",main = paste0("scale=", round(down_coe_loc*inital_scale,digits=0), "+", round(b0_coefficients[3]*bmax,digits=3), "*t*t"), xlab = "t", ylab = "Scale")
# rect(par("usr")[1], downboundary, par("usr")[2], upperboudary, col = col, border = NA)
# segments(0, downboundary, 166, upperboudary, col = "black",lwd=1, lty = 2)
# plot(random_numbers6, xlab = "t", ylab = "Discharge (m3/s)")
# 
# 
# plot(locations9, ylim = c(downboundary, upperboudary), pch = 16, col = "grey",main = paste0("b1=", round(b1_coefficients[3]*b,digits=2), ", b2=", round(b2_coefficients[3]*b,digits=2)), xlab = "t", ylab = "Scale")
# rect(par("usr")[1], downboundary, par("usr")[2], upperboudary, col = col, border = NA)
# segments(0, downboundary, 166, upperboudary, col = "black",lwd=1, lty = 2)
# plot(random_numbers9, xlab = "t", ylab = "Discharge (m3/s)")
# 
# 
# 
# #######---Figure 3
# inital_location <- 3000
# inital_scale <- 900
# inital_shape <- 0.15
# 
# upper_coe_loc <- 1.5
# down_coe_loc <- 0.8
# 
# upper_coe_sca <- 0.4
# down_coe_sca <- 0.2
# 
# b0_coefficients <- c(1,1/2,1/3)
# 
# b1_coefficients <- c(1/3,1/4,1/5)
# b2_coefficients <- c(1,1/3,1/2)
# 
# downboundary <- down_coe_loc*inital_location
# upperboudary <- upper_coe_loc*inital_location
# 
# b <- (upperboudary-downboundary)/(length(qcov)-1)
# bmax<-(upperboudary-downboundary)/((length(qcov)-1)^2)
# 
# 
# 
# locations1<-data_locsca_linear_1$location
# locations2<-data_locsca_linear_3$location
# locations3<-data_locsca_linear_3$location
# scales1<-data_locsca_linear_1$scale
# scales2<-data_locsca_linear_3$scale
# scales3<-data_locsca_linear_3$scale
# random_numbers1<-data_locsca_linear_1$random_numbers
# random_numbers2<-data_locsca_linear_2$random_numbers
# random_numbers3<-data_locsca_linear_3$random_numbers
# 
# 
# 
# locations4<-data_locsca_power_1$location
# locations5<-data_locsca_power_2$location
# locations6<-data_locsca_power_3$location
# scales4<-data_locsca_power_1$scale
# scales5<-data_locsca_power_3$scale
# scales6<-data_locsca_power_3$scale
# random_numbers4<-data_locsca_power_1$random_numbers
# random_numbers5<-data_locsca_power_2$random_numbers
# random_numbers6<-data_locsca_power_3$random_numbers
# 
# 
# locations7<-data_locsca_partial_1$location
# locations8<-data_locsca_partial_2$location
# locations9<-data_locsca_partial_3$location
# scales7<-data_locsca_partial_1$scale
# scales8<-data_locsca_partial_3$scale
# scales9<-data_locsca_partial_3$scale
# random_numbers7<-data_locsca_partial_1$random_numbers
# random_numbers8<-data_locsca_partial_2$random_numbers
# random_numbers9<-data_locsca_partial_3$random_numbers
# 
# 
# #### plot
# par(mfrow = c(1, 2), mar = c(5, 4, 4, 2) + 0.1, oma = c(0, 0, 0, 0))
# par(las = 0, font.main = 2, cex.main = 1)
# 
# 
# col <- adjustcolor("grey", alpha = 0.2)
# 
# plot(locations1, ylim = c(downboundary, upperboudary), pch = 16, col = "grey",main = paste0("location=", round(down_coe_loc*inital_location,digits=0), "+", round(b0_coefficients[1]*b,digits=2), "*t"), xlab = "t", ylab = "Location")
# rect(par("usr")[1], downboundary, par("usr")[2], upperboudary, col = col, border = NA)
# segments(0, downboundary, 166, upperboudary, col = "black",lwd=1, lty = 2)
# b01 <- (mean(locations1)*upper_coe_sca - mean(locations1)*down_coe_sca)/(length(qcov)-1)
# plot(scales1, ylim = c(mean(locations1)*down_coe_sca, mean(locations1)*upper_coe_sca), pch = 16, col = "grey",main = paste0("scale=", round(mean(locations1)*down_coe_sca,digits=0), "+", round(b0_coefficients[1]*b01,digits=2), "*t"), xlab = "t", ylab = "Scale")
# rect(par("usr")[1], mean(locations1)*down_coe_sca, par("usr")[2], mean(locations1)*upper_coe_sca, col = col, border = NA)
# segments(0, mean(locations1)*down_coe_sca, 166,  mean(locations1)*upper_coe_sca, col = "black",lwd=1, lty = 2)
# plot(random_numbers1,  xlab = "t", ylab = "Discharge (m3/s)", xlim = c(0, 166))
# 
# 
# plot(locations4, ylim = c(downboundary, upperboudary), pch = 16, col = "grey",main = paste0("location=", round(down_coe_loc*inital_location,digits=0), "+", round(b0_coefficients[1]*bmax,digits=2), "*t*t"), xlab = "t", ylab = "Location")
# rect(par("usr")[1], downboundary, par("usr")[2], upperboudary, col = col, border = NA)
# segments(0, downboundary, 166, upperboudary, col = "black",lwd=1, lty = 2)
# b01 <- (mean(locations4)*upper_coe_sca - mean(locations4)*down_coe_sca)/((length(qcov)-1)^2)
# plot(scales4, ylim = c(mean(locations4)*down_coe_sca, mean(locations4)*upper_coe_sca), pch = 16, col = "grey",main = paste0("scale=", round(mean(locations1)*down_coe_sca,digits=0), "+", round(b0_coefficients[1]*b01,digits=2), "*t*t"), xlab = "t", ylab = "Scale")
# rect(par("usr")[1], mean(locations4)*down_coe_sca, par("usr")[2], mean(locations4)*upper_coe_sca, col = col, border = NA)
# segments(0, mean(locations4)*down_coe_sca, 166,  mean(locations4)*upper_coe_sca, col = "black",lwd=1, lty = 2)
# plot(random_numbers4, xlab = "t", ylab = "Discharge (m3/s)")
# 
# 
# 
# plot(locations7, ylim = c(downboundary, upperboudary), pch = 16, col = "grey",main = paste0("b1=", round(b1_coefficients[1]*b,digits=2), ", b2=", round(b2_coefficients[1]*b,digits=2)), xlab = "t", ylab = "Location")
# rect(par("usr")[1], downboundary, par("usr")[2], upperboudary, col = col, border = NA)
# segments(0, downboundary, 166, upperboudary, col = "black",lwd=1, lty = 2)
# b01 <- (mean(locations7)*upper_coe_sca - mean(locations7)*down_coe_sca)/(length(qcov)-1)
# plot(scales7, ylim = c(mean(locations7)*down_coe_sca, mean(locations7)*upper_coe_sca), pch = 16, col = "grey",main = paste0("b1=", round(b1_coefficients[1]*b,digits=2), ", b2=", round(b2_coefficients[1]*b,digits=2)), xlab = "t", ylab = "Scale")
# rect(par("usr")[1], mean(locations7)*down_coe_sca, par("usr")[2], mean(locations7)*upper_coe_sca, col = col, border = NA)
# segments(0, mean(locations7)*down_coe_sca, 166, mean(locations7)*upper_coe_sca, col = "black",lwd=1, lty = 2)
# plot(random_numbers7, xlab = "t", ylab = "Discharge (m3/s)")
# 
# 
# plot(locations2, ylim = c(downboundary, upperboudary), pch = 16, col = "grey",main = paste0("location=", round(down_coe_loc*inital_location,digits=0), "+", round(b0_coefficients[2]*b,digits=2), "*t"), xlab = "t", ylab = "Location")
# rect(par("usr")[1], downboundary, par("usr")[2], upperboudary, col = col, border = NA)
# segments(0, downboundary, 166, upperboudary, col = "black",lwd=1, lty = 2)
# b01 <- (mean(locations2)*upper_coe_sca - mean(locations2)*down_coe_sca)/(length(qcov)-1)
# plot(scales2, ylim = c(mean(locations2)*down_coe_sca, mean(locations2)*upper_coe_sca), pch = 16, col = "grey",main = paste0("scale=", round(mean(locations1)*down_coe_sca,digits=0), "+", round(b0_coefficients[2]*b01,digits=2), "*t"), xlab = "t", ylab = "Scale")
# rect(par("usr")[1], mean(locations2)*down_coe_sca, par("usr")[2], mean(locations2)*upper_coe_sca, col = col, border = NA)
# segments(0, mean(locations2)*down_coe_sca, 166,  mean(locations2)*upper_coe_sca, col = "black",lwd=1, lty = 2)
# plot(random_numbers2,  xlab = "t", ylab = "Discharge (m3/s)", xlim = c(0, 166))
# 
# 
# plot(locations5, ylim = c(downboundary, upperboudary), pch = 16, col = "grey",main = paste0("location=", round(down_coe_loc*inital_location,digits=0), "+", round(b0_coefficients[2]*bmax,digits=2), "*t*t"), xlab = "t", ylab = "Location")
# rect(par("usr")[1], downboundary, par("usr")[2], upperboudary, col = col, border = NA)
# segments(0, downboundary, 166, upperboudary, col = "black",lwd=1, lty = 2)
# b01 <- (mean(locations5)*upper_coe_sca - mean(locations5)*down_coe_sca)/((length(qcov)-1)^2)
# plot(scales5, ylim = c(mean(locations5)*down_coe_sca, mean(locations5)*upper_coe_sca), pch = 16, col = "grey",main = paste0("scale=", round(mean(locations1)*down_coe_sca,digits=0), "+", round(b0_coefficients[2]*b01,digits=2), "*t*t"), xlab = "t", ylab = "Scale")
# rect(par("usr")[1], mean(locations5)*down_coe_sca, par("usr")[2], mean(locations5)*upper_coe_sca, col = col, border = NA)
# segments(0, mean(locations5)*down_coe_sca, 166,  mean(locations5)*upper_coe_sca, col = "black",lwd=1, lty = 2)
# plot(random_numbers5, xlab = "t", ylab = "Discharge (m3/s)")
# 
# 
# 
# plot(locations8, ylim = c(downboundary, upperboudary), pch = 16, col = "grey",main = paste0("b1=", round(b1_coefficients[2]*b,digits=2), ", b2=", round(b2_coefficients[2]*b,digits=2)), xlab = "t", ylab = "Location")
# rect(par("usr")[1], downboundary, par("usr")[2], upperboudary, col = col, border = NA)
# segments(0, downboundary, 166, upperboudary, col = "black",lwd=1, lty = 2)
# b01 <- (mean(locations8)*upper_coe_sca - mean(locations8)*down_coe_sca)/(length(qcov)-1)
# plot(scales8, ylim = c(mean(locations8)*down_coe_sca, mean(locations8)*upper_coe_sca), pch = 16, col = "grey",main = paste0("b1=", round(b1_coefficients[2]*b,digits=2), ", b2=", round(b2_coefficients[2]*b,digits=2)), xlab = "t", ylab = "Scale")
# rect(par("usr")[1], mean(locations8)*down_coe_sca, par("usr")[2], mean(locations8)*upper_coe_sca, col = col, border = NA)
# segments(0, mean(locations8)*down_coe_sca, 166, mean(locations8)*upper_coe_sca, col = "black",lwd=1, lty = 2)
# plot(random_numbers8, xlab = "t", ylab = "Discharge (m3/s)")
# 
# 
# 
# plot(locations3, ylim = c(downboundary, upperboudary), pch = 16, col = "grey",main = paste0("location=", round(down_coe_loc*inital_location,digits=0), "+", round(b0_coefficients[3]*b,digits=2), "*t"), xlab = "t", ylab = "Location")
# rect(par("usr")[1], downboundary, par("usr")[2], upperboudary, col = col, border = NA)
# segments(0, downboundary, 166, upperboudary, col = "black",lwd=1, lty = 2)
# b01 <- (mean(locations3)*upper_coe_sca - mean(locations3)*down_coe_sca)/(length(qcov)-1)
# plot(scales3, ylim = c(mean(locations3)*down_coe_sca, mean(locations3)*upper_coe_sca), pch = 16, col = "grey",main = paste0("scale=", round(mean(locations1)*down_coe_sca,digits=0), "+", round(b0_coefficients[3]*b01,digits=2), "*t"), xlab = "t", ylab = "Scale")
# rect(par("usr")[1], mean(locations3)*down_coe_sca, par("usr")[2], mean(locations3)*upper_coe_sca, col = col, border = NA)
# segments(0, mean(locations3)*down_coe_sca, 166,  mean(locations3)*upper_coe_sca, col = "black",lwd=1, lty = 2)
# plot(random_numbers3,  xlab = "t", ylab = "Discharge (m3/s)", xlim = c(0, 166))
# 
# 
# plot(locations6, ylim = c(downboundary, upperboudary), pch = 16, col = "grey",main = paste0("location=", round(down_coe_loc*inital_location,digits=0), "+", round(b0_coefficients[3]*bmax,digits=2), "*t*t"), xlab = "t", ylab = "Location")
# rect(par("usr")[1], downboundary, par("usr")[2], upperboudary, col = col, border = NA)
# segments(0, downboundary, 166, upperboudary, col = "black",lwd=1, lty = 2)
# b01 <- (mean(locations6)*upper_coe_sca - mean(locations6)*down_coe_sca)/((length(qcov)-1)^2)
# plot(scales6, ylim = c(mean(locations6)*down_coe_sca, mean(locations6)*upper_coe_sca), pch = 16, col = "grey",main = paste0("scale=", round(mean(locations1)*down_coe_sca,digits=0), "+", round(b0_coefficients[3]*b01,digits=2), "*t*t"), xlab = "t", ylab = "Scale")
# rect(par("usr")[1], mean(locations6)*down_coe_sca, par("usr")[2], mean(locations5)*upper_coe_sca, col = col, border = NA)
# segments(0, mean(locations6)*down_coe_sca, 166,  mean(locations6)*upper_coe_sca, col = "black",lwd=1, lty = 2)
# plot(random_numbers6, xlab = "t", ylab = "Discharge (m3/s)")
# 
# 
# 
# plot(locations9, ylim = c(downboundary, upperboudary), pch = 16, col = "grey",main = paste0("b1=", round(b1_coefficients[3]*b,digits=2), ", b2=", round(b2_coefficients[3]*b,digits=2)), xlab = "t", ylab = "Location")
# rect(par("usr")[1], downboundary, par("usr")[2], upperboudary, col = col, border = NA)
# segments(0, downboundary, 166, upperboudary, col = "black",lwd=1, lty = 2)
# b01 <- (mean(locations9)*upper_coe_sca - mean(locations9)*down_coe_sca)/(length(qcov)-1)
# plot(scales9, ylim = c(mean(locations9)*down_coe_sca, mean(locations9)*upper_coe_sca), pch = 16, col = "grey",main = paste0("b1=", round(b1_coefficients[3]*b,digits=2), ", b2=", round(b2_coefficients[3]*b,digits=2)), xlab = "t", ylab = "Scale")
# rect(par("usr")[1], mean(locations9)*down_coe_sca, par("usr")[2], mean(locations9)*upper_coe_sca, col = col, border = NA)
# segments(0, mean(locations9)*down_coe_sca, 166, mean(locations9)*upper_coe_sca, col = "black",lwd=1, lty = 2)
# plot(random_numbers9, xlab = "t", ylab = "Discharge (m3/s)")
```

**To run the code to estimate flood extremes**
You need to load the data and assign it to the currentdata. Then, run
all the codes below from this chunk.
```{r}
# Here, we just take examples from the above chunk,
# i.e., data_loc_linear_1, data_loc_linear_2, data_loc_linear_3
# or data_loc_power_1, data_loc_power_2, data_loc_power_3
# or data_loc_partial_1, data_loc_partial_2, data_loc_partial_3

# You can read data from csv file as well.

# data_loc_linear_1: for example, this is a dataframe generated from your synthetic data

currentdata <- data_loc_linear_2

raw_data <- data.frame(year = seq(1850,2015),
                          maxVal = currentdata$random_numbers,
                          flow100 = currentdata$return_level)


window_size <- 30
return_periods <- c(30,50,100) # set the return periods


```

**applying moving window with multiple approaches.**
```{r}
## apply moving window to estimate flood extremes

##################
####Using method 0 (without any outlier removal)

dataTemp  <- raw_data
df_ini <- Discharge_at_GivenReturnPeriodandSamples(dataTemp,window_size,return_periods)

##################
####Using method 1.

dataTemp_1  <- raw_data 
dataTemp_1 <- Reject_outliers_method1(dataTemp_1,threshold_returnPeriod=50,chunk=30)
dataTemp_1$r <- NULL
df_one <- Discharge_at_GivenReturnPeriodandSamples(dataTemp_1,window_size,return_periods)


##################
####Using method 2.

dataTemp_2  <- raw_data 
dataTemp_2 <- Reject_outliers_method2(dataTemp_2,window_size=30,threshold_times = 2)
dataTemp_3<-dataTemp_2
dataTemp_3$frequency <- NULL
df_two <- Discharge_at_GivenReturnPeriodandSamples(dataTemp_3,window_size,return_periods)


##################
####Using GAMLSS methods.
data_second <- GamlssFigure1Data(raw_data,baseyear = 1950)

```

**combine the data and then plot.**
```{r}

na_indices <- which(is.na(dataTemp_1$maxVal))
outlier_raw_1<- raw_data[na_indices, ]
na_indices <- which(is.na(dataTemp_2$maxVal))
outlier_raw_2<- raw_data[na_indices, ]


mw<-df_ini$return_100
gamlass<-data_second$flood_magnitude_100yr
mw_outlier1<-df_one$return_100
mw_outlier2<-df_two$return_100
flow_100<-raw_data$flow100


mwdf<-data.frame(raw_data$year[window_size:nrow(raw_data)], mw)
gamlassdf<-data.frame(raw_data$year, gamlass)
origindf<-data.frame(raw_data$year, flow_100)
outlierdf_1<-data.frame(raw_data$year[window_size:nrow(raw_data)], mw_outlier1)
outlierdf_2<-data.frame(raw_data$year[window_size:nrow(raw_data)], mw_outlier2)


outlier_1<-data.frame(outlier_raw_1$year, outlier_raw_1$maxVal)
outlier_2<-data.frame(outlier_raw_2$year, outlier_raw_2$maxVal)


names(mwdf)<-c("year","mw_100")
names(gamlassdf)<-c("year","gamlass_100")
names(origindf)<-c("year","orgin_100")
names(outlierdf_1)<-c("year","outlier1_100")
names(outlierdf_2)<-c("year","outlier2_100")

names(outlier_1)<-c("year","outlier_1")
names(outlier_2)<-c("year","outlier_2")


reswl_all<- merge(gamlassdf,mwdf, by="year", all=TRUE)
reswl_all<- merge(raw_data,reswl_all, by="year", all=TRUE)
reswl_all<- merge(origindf,reswl_all, by="year", all=TRUE)
reswl_all<- merge(reswl_all,outlierdf_1,by="year", all=TRUE)
reswl_all<- merge(reswl_all,outlierdf_2,by="year", all=TRUE)
reswl_all<- merge(reswl_all,outlier_1,by="year", all=TRUE)
reswl_all<- merge(reswl_all,outlier_2,by="year", all=TRUE)
reswl_all


```

**plot the figure**
```{r}

mytheme <- theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, size = 10, hjust = 1, color = 'black'),
    axis.text.y = element_text(size = 10, color = 'black'),
    axis.ticks = element_line(linetype = 1, color = 'black'),
    legend.text = element_text(size = 7),  # Adjust the legend text size
    axis.title = element_text(size = 10),
    panel.border = element_rect(colour = "black", fill = NA, size = 0.5),
    legend.title = element_blank(),
    legend.position = c(0.15, 0.83),  # Adjust the position of the legend to top left
    legend.background = element_rect(color = "gray", fill = "white"),  # Set the legend background
    legend.key.size = unit(0.4, "lines")  # Adjust the size of the legend key
  )


reswl_all2 <- reswl_all[,c("year","maxVal","orgin_100","gamlass_100","mw_100","outlier1_100","outlier2_100","outlier_1","outlier_2")]
                        
names(reswl_all2) <- c("year","rawdata","truth","gamlass","mw","mwOutlier1","mwOutlier2","Outlier1","Outlier2")


data_melt2 <- melt(reswl_all2,id.vars = 'year', variable.name='DataSouces',value.name='waterlevel')
pll<-ggplot(data_melt2, aes(x=year, y=waterlevel, colour=DataSouces,linetype=DataSouces,shape=DataSouces))+
      mytheme+
      labs(title = "Figure 1")+
      geom_line(size=1)+
      geom_point(alpha=1,size=2)+
      scale_color_manual("waterlevel",
                         values =  c("rawdata"  = "gray80", 
                                     "truth"       = "#3f60aa",
                                     "gamlass"   = "#cc340c",
                                     "mw"       = "#f18800",
                                     "mwOutlier1"  = "#9ec417",
                                     "mwOutlier2"  = "#44c1f0",
                                     "Outlier1" = "#e8490f",
                                     "Outlier2" = "#e4ce00"))+
      scale_shape_manual("waterlevel"     ,values=c(16,NA,NA,NA,NA,NA,16,16))+
      scale_linetype_manual("waterlevel"  ,values=c(0,1,1,1,1,1,0,0)) +
      labs(y = expression(paste("AMAX [m"^3*"/s]"))) +
      labs(x = "Year") +
      scale_x_continuous(breaks = seq(1850, 2015, by = 15)) +
      theme(legend.position = c(0.01, 0.99), legend.justification = c(0, 1)) +
      guides(color=guide_legend(nrow=5, byrow=FALSE))
pll

```

**Evaluation**
```{r}

# we get the output dataframe like this: 
# names(reswl_all)
#  [1] "year"         "orgin_100"    "maxVal"       "flow100"      "gamlass_100"  
# "mw_100"       "outlier1_100" "outlier2_100" "outlier_1"    "outlier_2"   

## we use two statistical metrics to quantify the good-fitness of simulated and observed flood maginitudes.
tags <- "changingLocation_Linear_b1_1_2"
evaluation_results <- data.frame(sae_outlier1 = mae(reswl_all$orgin_100,
                                                         reswl_all$outlier1_100),
                                 sae_outlier2 = mae(reswl_all$orgin_100,
                                                         reswl_all$outlier2_100),
                                 sae_gamlass = mae(reswl_all$orgin_100,
                                                         reswl_all$gamlass_100),
                                 sae_mw = mae(reswl_all$orgin_100,
                                                         reswl_all$mw_100),
                                 pbias_outlier1 = pbias(reswl_all$orgin_100,
                                               reswl_all$outlier1_100),
                                 pbias_outlier2 = pbias(reswl_all$orgin_100,
                                               reswl_all$outlier2_100),
                                 pbias_gamlass = pbias(reswl_all$orgin_100,
                                               reswl_all$gamlass_100),
                                 pbias_mw = pbias(reswl_all$orgin_100,
                                               reswl_all$mw_100),
                                 Tag = tags)
evaluation_results
```

**To generate synthetic data and save the data in the csv files.**
**Main code Save csv Read csv**
```{r}

################## 
######## Main code

```
